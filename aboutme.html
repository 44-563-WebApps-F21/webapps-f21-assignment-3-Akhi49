<!DOCTYPE html>
<html>
    <head>
        <title>HERO</title>
        </head>
    <body>
        <h1 Style="font-family:Times;color: darkseagreen;">
            HULK
        </h1>
<p>
    For his size, the Hulk is incredibly fast and can run great distances at extreme speeds. 
    He generally travels by jumping as described above though. The hulk is also <b>highly resistant</b> to damage, being near impervious to most forms of damage.
     Very little has been known to faze the Hulk, except those of the same <b>power level</b>> as the Hulk such as The Thing, Thor, Abomination, and others.
</p>
</br>
<img src="hulk.jpg" alt=HUlk>
<hr>
<h2 style ="font-family: times; color:forestgreen;">
Minimum Spanning Tree-Prims algorithm
</h2>
<blockquote>
    Given a weighted, undirected graph G with n vertices and m edges. You want to
     find a spanning tree of this graph which connects all vertices and has the 
     least weight (i.e. the sum of weights of edges is minimal). A spanning tree 
     is a set of edges such that any vertex can reach any other by exactly one simple 
    path. The spanning tree with the least weight is called a minimum spanning tree.
</br>
<a href = "https://cp-algorithms.com/graph/mst_prim.html">source</a>
</blockquote>

<pre>
    const int INF = 1000000000;

    struct Edge {
        int w = INF, to = -1;
        bool operator<(Edge const& other) const {
            return make_pair(w, to) < make_pair(other.w, other.to);
        }
    };
    
    int n;
    vector<vector<Edge>> adj;
    
    void prim() {
        int total_weight = 0;
        vector<Edge> min_e(n);
        min_e[0].w = 0;
        set<Edge> q;
        q.insert({0, 0});
        vector<bool> selected(n, false);
        for (int i = 0; i < n; ++i) {
            if (q.empty()) {
                cout << "No MST!" << endl;
                exit(0);
            }
    
            int v = q.begin()->to;
            selected[v] = true;
            total_weight += q.begin()->w;
            q.erase(q.begin());
    
            if (min_e[v].to != -1)
                cout << v << " " << min_e[v].to << endl;
    
            for (Edge e : adj[v]) {
                if (!selected[e.to] && e.w < min_e[e.to].w) {
                    q.erase({min_e[e.to].w, e.to});
                    min_e[e.to] = {e.w, v};
                    q.insert({e.w, e.to});
                }
            }
        }
    
        cout << total_weight << endl;
    }
</pre>

</body>
</html>